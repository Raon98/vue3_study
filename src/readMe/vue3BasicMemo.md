# vue3 Basic Memo

### v-html 디렉티브를 이용한 HTML 표현
```vue
- v-html 디렉티브는 HTML 엘리먼트의 innerHTML 값에 변수값을 전달해 HTML 마크업 언어로 표현
- 변수는 반드시 HTML 평문이어야 하며, VUE의 문법을 사용해도 컴파일 되지않는다.
    <div v-html="<i>HTML TEXT</i>"></div>
```

### v-pre 디렉티브를 이용한 컴파일 무시
```vue
- v-pre 디렉티브를 이용하면 해당 엘리먼트를 포함한 모든 자식 엘리먼트들의 값을 컴파일 하지않는다.
 즉, 수염표기법으로 변수를 포기 하더라도 있는 그래도 출력이 된다.
    <div>{{msg}}</div> = msg = HELLO
    <div v-pre>{{msg}}</div> = msg = {{msg}}그대로 표현
```

### 데이터 결합을 통한 사용자 입력 처리
```vue
 [참조] declarativeRendering.Vue
 
- 탭플릿 내에서 v-bind 디렉티브 혹은 v-model 디렉티브를 이용할 경우 컴포넌트에서 선언한 변수와 HTML 태그 속성을 결합할 수 있다.
    v-bind:HTML속성 = "변수명" === :HTML속성="변수명" (콜론대체가능)
    ⇒ v-bind:title="title_value" , :title="title_value"
 * v-bind 디렉티브 : 단방향 결합 지원
   v-model 디렉티브 : 양방향 결합 지원
 #단방향 결합 : 변수의 값이 템플릿으로만 결합되어 템플릿의 HTML 태그가 변경한 값이 변수에 돌아오지 않는다는 뜻
 #양방향 결합 : 변수의 변경이 템플릿의 DOM에 영향을 미치는것 + 템플릿에서의 변경이 변수의 값을 변경
```

### v-model 디렉티브 수식어
```vue
 - v-model 디렉티브로 연결되는 변수명은 컴포넌트의 props에 정의하면 되는데, 변수명 뒤에 Modifiers라는 글자를 붙여
   props에 추가적으로 선언하면 사용자 수식어를 받아올 수 있다.
    props : [ "a" , "aModifiers" ]
```

### 이벤트 리스너를 이용한 사용자 입력 처리
```vue
 [참조] eventListenerEx
 - v-on 디렉티브는 HTML 태그뿐만 아니라 사용자가 만든 컴포넌트에서 발생된 이벤트를 캡쳐할 떄도 사용
   click = @click="스크립트 코드, 혹은 함수 호출"
   
 <이벤트 수식어>
 .stop : 이벤트 전파를 방지 ::stopPropagation()과 동일
 .prevent : 브라우저의 기본 동작을 금지한다. ::preventDefault()와 동일
 .capture : 이벤트리스너의 capture 옵션을 활성화시킨다.
 .self : 이벤트가 자식 엘리먼트가 아닌 현재 엘리먼트에서 발생했을 떄만 핸들러를 호출
 .once : 최대 한번의 클릭만 허용한다.
       ::once.prevent와 같이 사용하면 처음 클릭 시 태그의 본연 기능을 방지하고 원하는 기능을 수행할 수 있다.
 .passive : 이벤트리스너의 passive 옵션을 활성화 시킨다.
 .exact : 정확히 해당 키만 눌렸을 떄 핸들러를 호출한다.
 .left : 마우스 왼쪽 버튼이 눌렀을 떄 핸들러를 호출한다.
 .right : 마우스의 오른쪽 버튼이 눌렀을 때 핸들러를 호출한다.
 .middle : 마우스의 가운데 버튼이 눌렀을 떄 핸들러를 호출한다.

<이벤트수식어>
 - 버튼이 활성화되어 있을 떄 키보드의 Enter key를 누르면 해당 버튼이 클릭된 것과 같은 효과를 보인다.
 - 일반적으로 keyup 이벤트에 대해 수식어를 불여 키보드 입력을 수정한다.
     <input @keyup.enter.prevent/>
```

### 템플릿 내 조건문 (v-if)
```vue
  [참조] v-ifEx
 - v-if 디렉티브를 사용한 조건문은 일반적인 스크립트 문법을 따른다.
    <div v-if="cnt > 0"/>
    <div v-if="text === 'text"/>
 - v-if-else
    <div v-if="cnt > 0"/>
    <div v-else-if="cnt === 2"/>
    <div v-else/>
 
  # 템플릿의 역할
   - HTML로 구성된 부분으로 컴포넌트에서 생성된 데이터를 선언적으로 DOM과 결합시켜주는 역할
   - 템플릿은 Vue가 컴파일을 할 떄 가상 DOM 렌더함수(Vue.h)로 변경
   - 가상 DOM 렌더함수를 쓰는 이유 : 실제 DOM의 변경을 최소화 하기 위해서

  # v-if: 1. 조건이 변경되면 조건 내 DOM 엘리먼트를 처음부터 다시 그리지만 
          2. 빠르게 애플리케이션의 그림을 그려주지만 조건이 변경될 떄마다 다시 해당엘리먼트를 그려야 함
  # v-show : 1. 모든 조건의 DOM 엘리먼트를 그린 후 조건에 맞지 않는 엘리먼트는 hide 처리한다.
             2. 처음에는 조금 늦게 그릴지 몰라도 조건이 자주 변경될 떄는 매우 빠른 전환이 이뤄진다.

  ##따라서 .. 자주 안바뀔경우 v-if 자주 바뀌경우 v-show가 유리
```

### 템플릿 내 반복문 (v-for)
```vue
    <div v-for="item in itemList"/>
    <div v-for="(item,i) in itemList" :key="i"/>
 - v-for 디렉티브가 쓰여진 엘리먼트와 그 자식 노드들은 반복문이 도는 횟수만큼 생성한다.
 - 생성된 각 엘리먼트는 각 순회단계에서 나온 값을 반게 된다.
 - v-for 함수를 사용할 떄는 언제나 key 속성을 같이 사용하는것이 좋다.
   => 템플릿이 가상 DOM 렌더 함수로 변활될 때 같은 태그를 재활용 하기 떄문
   => Vue의 가상노드는 <input/>태그와 변수를 짝지울수 없다. 따라서, :key라는 속성을 각자 이름을 가지게 해야된다.
```

### Computed 속성
```vue 
[참조]computedEx
 - 계산된 속성 (Computed Properties)은 반응형 애플리케이션을 구현하는 데 가장 큰역할
 - Vue의 계산된 속성은 내부 반응성 변수의 값이 변하지 않는다면 그 결과를 캐시에서 바로 꺼내서 사용
  => 단순히 캐시에서 꺼내는 것이 아니라 DOM 업데이트 자체를 진행하지 않는다.
 #반면 함수는 호출되면 반드시 새롭게 계싼을 진행하고 DOM을 업데이트한다.
```

